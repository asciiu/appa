// Code generated by protoc-gen-go. DO NOT EDIT.
// source: proto/key/key.proto

/*
Package key is a generated protocol buffer package.

It is generated from these files:
	proto/key/key.proto

It has these top-level messages:
	KeyRequest
	GetUserKeyRequest
	GetKeysRequest
	GetUserKeysRequest
	RemoveKeyRequest
	Key
	UserKeyData
	UserKeysData
	KeyResponse
	KeyListResponse
*/
package key

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	client "github.com/micro/go-micro/client"
	server "github.com/micro/go-micro/server"
	context "golang.org/x/net/context"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Requests
type KeyRequest struct {
	KeyID       string `protobuf:"bytes,1,opt,name=keyID" json:"keyID"`
	UserID      string `protobuf:"bytes,2,opt,name=userID" json:"userID"`
	Exchange    string `protobuf:"bytes,3,opt,name=exchange" json:"exchange"`
	Key         string `protobuf:"bytes,4,opt,name=key" json:"key"`
	Secret      string `protobuf:"bytes,5,opt,name=secret" json:"secret"`
	Description string `protobuf:"bytes,6,opt,name=description" json:"description"`
	Status      string `protobuf:"bytes,7,opt,name=status" json:"status"`
}

func (m *KeyRequest) Reset()                    { *m = KeyRequest{} }
func (m *KeyRequest) String() string            { return proto.CompactTextString(m) }
func (*KeyRequest) ProtoMessage()               {}
func (*KeyRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *KeyRequest) GetKeyID() string {
	if m != nil {
		return m.KeyID
	}
	return ""
}

func (m *KeyRequest) GetUserID() string {
	if m != nil {
		return m.UserID
	}
	return ""
}

func (m *KeyRequest) GetExchange() string {
	if m != nil {
		return m.Exchange
	}
	return ""
}

func (m *KeyRequest) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *KeyRequest) GetSecret() string {
	if m != nil {
		return m.Secret
	}
	return ""
}

func (m *KeyRequest) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *KeyRequest) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

type GetUserKeyRequest struct {
	UserID string `protobuf:"bytes,1,opt,name=userID" json:"userID"`
	KeyID  string `protobuf:"bytes,2,opt,name=keyID" json:"keyID"`
}

func (m *GetUserKeyRequest) Reset()                    { *m = GetUserKeyRequest{} }
func (m *GetUserKeyRequest) String() string            { return proto.CompactTextString(m) }
func (*GetUserKeyRequest) ProtoMessage()               {}
func (*GetUserKeyRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *GetUserKeyRequest) GetUserID() string {
	if m != nil {
		return m.UserID
	}
	return ""
}

func (m *GetUserKeyRequest) GetKeyID() string {
	if m != nil {
		return m.KeyID
	}
	return ""
}

type GetKeysRequest struct {
	KeyIDs []string `protobuf:"bytes,1,rep,name=keyIDs" json:"keyIDs"`
}

func (m *GetKeysRequest) Reset()                    { *m = GetKeysRequest{} }
func (m *GetKeysRequest) String() string            { return proto.CompactTextString(m) }
func (*GetKeysRequest) ProtoMessage()               {}
func (*GetKeysRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *GetKeysRequest) GetKeyIDs() []string {
	if m != nil {
		return m.KeyIDs
	}
	return nil
}

type GetUserKeysRequest struct {
	UserID string `protobuf:"bytes,1,opt,name=userID" json:"userID"`
}

func (m *GetUserKeysRequest) Reset()                    { *m = GetUserKeysRequest{} }
func (m *GetUserKeysRequest) String() string            { return proto.CompactTextString(m) }
func (*GetUserKeysRequest) ProtoMessage()               {}
func (*GetUserKeysRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *GetUserKeysRequest) GetUserID() string {
	if m != nil {
		return m.UserID
	}
	return ""
}

type RemoveKeyRequest struct {
	UserID string `protobuf:"bytes,1,opt,name=userID" json:"userID"`
	KeyID  string `protobuf:"bytes,2,opt,name=keyID" json:"keyID"`
}

func (m *RemoveKeyRequest) Reset()                    { *m = RemoveKeyRequest{} }
func (m *RemoveKeyRequest) String() string            { return proto.CompactTextString(m) }
func (*RemoveKeyRequest) ProtoMessage()               {}
func (*RemoveKeyRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *RemoveKeyRequest) GetUserID() string {
	if m != nil {
		return m.UserID
	}
	return ""
}

func (m *RemoveKeyRequest) GetKeyID() string {
	if m != nil {
		return m.KeyID
	}
	return ""
}

// Responses
type Key struct {
	KeyID       string `protobuf:"bytes,1,opt,name=keyID" json:"keyID"`
	UserID      string `protobuf:"bytes,2,opt,name=userID" json:"userID"`
	Exchange    string `protobuf:"bytes,3,opt,name=exchange" json:"exchange"`
	Key         string `protobuf:"bytes,4,opt,name=key" json:"key"`
	Secret      string `protobuf:"bytes,5,opt,name=secret" json:"secret"`
	Status      string `protobuf:"bytes,6,opt,name=status" json:"status"`
	Description string `protobuf:"bytes,7,opt,name=description" json:"description"`
}

func (m *Key) Reset()                    { *m = Key{} }
func (m *Key) String() string            { return proto.CompactTextString(m) }
func (*Key) ProtoMessage()               {}
func (*Key) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *Key) GetKeyID() string {
	if m != nil {
		return m.KeyID
	}
	return ""
}

func (m *Key) GetUserID() string {
	if m != nil {
		return m.UserID
	}
	return ""
}

func (m *Key) GetExchange() string {
	if m != nil {
		return m.Exchange
	}
	return ""
}

func (m *Key) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *Key) GetSecret() string {
	if m != nil {
		return m.Secret
	}
	return ""
}

func (m *Key) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *Key) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

type UserKeyData struct {
	Key *Key `protobuf:"bytes,1,opt,name=key" json:"key"`
}

func (m *UserKeyData) Reset()                    { *m = UserKeyData{} }
func (m *UserKeyData) String() string            { return proto.CompactTextString(m) }
func (*UserKeyData) ProtoMessage()               {}
func (*UserKeyData) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *UserKeyData) GetKey() *Key {
	if m != nil {
		return m.Key
	}
	return nil
}

type UserKeysData struct {
	Keys []*Key `protobuf:"bytes,1,rep,name=keys" json:"keys"`
}

func (m *UserKeysData) Reset()                    { *m = UserKeysData{} }
func (m *UserKeysData) String() string            { return proto.CompactTextString(m) }
func (*UserKeysData) ProtoMessage()               {}
func (*UserKeysData) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *UserKeysData) GetKeys() []*Key {
	if m != nil {
		return m.Keys
	}
	return nil
}

type KeyResponse struct {
	Status  string       `protobuf:"bytes,1,opt,name=status" json:"status"`
	Message string       `protobuf:"bytes,2,opt,name=message" json:"message"`
	Data    *UserKeyData `protobuf:"bytes,3,opt,name=data" json:"data"`
}

func (m *KeyResponse) Reset()                    { *m = KeyResponse{} }
func (m *KeyResponse) String() string            { return proto.CompactTextString(m) }
func (*KeyResponse) ProtoMessage()               {}
func (*KeyResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *KeyResponse) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *KeyResponse) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *KeyResponse) GetData() *UserKeyData {
	if m != nil {
		return m.Data
	}
	return nil
}

type KeyListResponse struct {
	Status  string        `protobuf:"bytes,1,opt,name=status" json:"status"`
	Message string        `protobuf:"bytes,2,opt,name=message" json:"message"`
	Data    *UserKeysData `protobuf:"bytes,3,opt,name=data" json:"data"`
}

func (m *KeyListResponse) Reset()                    { *m = KeyListResponse{} }
func (m *KeyListResponse) String() string            { return proto.CompactTextString(m) }
func (*KeyListResponse) ProtoMessage()               {}
func (*KeyListResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *KeyListResponse) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *KeyListResponse) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *KeyListResponse) GetData() *UserKeysData {
	if m != nil {
		return m.Data
	}
	return nil
}

func init() {
	proto.RegisterType((*KeyRequest)(nil), "KeyRequest")
	proto.RegisterType((*GetUserKeyRequest)(nil), "GetUserKeyRequest")
	proto.RegisterType((*GetKeysRequest)(nil), "GetKeysRequest")
	proto.RegisterType((*GetUserKeysRequest)(nil), "GetUserKeysRequest")
	proto.RegisterType((*RemoveKeyRequest)(nil), "RemoveKeyRequest")
	proto.RegisterType((*Key)(nil), "Key")
	proto.RegisterType((*UserKeyData)(nil), "UserKeyData")
	proto.RegisterType((*UserKeysData)(nil), "UserKeysData")
	proto.RegisterType((*KeyResponse)(nil), "KeyResponse")
	proto.RegisterType((*KeyListResponse)(nil), "KeyListResponse")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ client.Option
var _ server.Option

// Client API for KeyService service

type KeyServiceClient interface {
	AddKey(ctx context.Context, in *KeyRequest, opts ...client.CallOption) (*KeyResponse, error)
	GetKeys(ctx context.Context, in *GetKeysRequest, opts ...client.CallOption) (*KeyListResponse, error)
	GetUserKey(ctx context.Context, in *GetUserKeyRequest, opts ...client.CallOption) (*KeyResponse, error)
	GetUserKeys(ctx context.Context, in *GetUserKeysRequest, opts ...client.CallOption) (*KeyListResponse, error)
	RemoveKey(ctx context.Context, in *RemoveKeyRequest, opts ...client.CallOption) (*KeyResponse, error)
	UpdateKeyDescription(ctx context.Context, in *KeyRequest, opts ...client.CallOption) (*KeyResponse, error)
}

type keyServiceClient struct {
	c           client.Client
	serviceName string
}

func NewKeyServiceClient(serviceName string, c client.Client) KeyServiceClient {
	if c == nil {
		c = client.NewClient()
	}
	if len(serviceName) == 0 {
		serviceName = "keyservice"
	}
	return &keyServiceClient{
		c:           c,
		serviceName: serviceName,
	}
}

func (c *keyServiceClient) AddKey(ctx context.Context, in *KeyRequest, opts ...client.CallOption) (*KeyResponse, error) {
	req := c.c.NewRequest(c.serviceName, "KeyService.AddKey", in)
	out := new(KeyResponse)
	err := c.c.Call(ctx, req, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keyServiceClient) GetKeys(ctx context.Context, in *GetKeysRequest, opts ...client.CallOption) (*KeyListResponse, error) {
	req := c.c.NewRequest(c.serviceName, "KeyService.GetKeys", in)
	out := new(KeyListResponse)
	err := c.c.Call(ctx, req, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keyServiceClient) GetUserKey(ctx context.Context, in *GetUserKeyRequest, opts ...client.CallOption) (*KeyResponse, error) {
	req := c.c.NewRequest(c.serviceName, "KeyService.GetUserKey", in)
	out := new(KeyResponse)
	err := c.c.Call(ctx, req, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keyServiceClient) GetUserKeys(ctx context.Context, in *GetUserKeysRequest, opts ...client.CallOption) (*KeyListResponse, error) {
	req := c.c.NewRequest(c.serviceName, "KeyService.GetUserKeys", in)
	out := new(KeyListResponse)
	err := c.c.Call(ctx, req, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keyServiceClient) RemoveKey(ctx context.Context, in *RemoveKeyRequest, opts ...client.CallOption) (*KeyResponse, error) {
	req := c.c.NewRequest(c.serviceName, "KeyService.RemoveKey", in)
	out := new(KeyResponse)
	err := c.c.Call(ctx, req, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keyServiceClient) UpdateKeyDescription(ctx context.Context, in *KeyRequest, opts ...client.CallOption) (*KeyResponse, error) {
	req := c.c.NewRequest(c.serviceName, "KeyService.UpdateKeyDescription", in)
	out := new(KeyResponse)
	err := c.c.Call(ctx, req, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for KeyService service

type KeyServiceHandler interface {
	AddKey(context.Context, *KeyRequest, *KeyResponse) error
	GetKeys(context.Context, *GetKeysRequest, *KeyListResponse) error
	GetUserKey(context.Context, *GetUserKeyRequest, *KeyResponse) error
	GetUserKeys(context.Context, *GetUserKeysRequest, *KeyListResponse) error
	RemoveKey(context.Context, *RemoveKeyRequest, *KeyResponse) error
	UpdateKeyDescription(context.Context, *KeyRequest, *KeyResponse) error
}

func RegisterKeyServiceHandler(s server.Server, hdlr KeyServiceHandler, opts ...server.HandlerOption) {
	s.Handle(s.NewHandler(&KeyService{hdlr}, opts...))
}

type KeyService struct {
	KeyServiceHandler
}

func (h *KeyService) AddKey(ctx context.Context, in *KeyRequest, out *KeyResponse) error {
	return h.KeyServiceHandler.AddKey(ctx, in, out)
}

func (h *KeyService) GetKeys(ctx context.Context, in *GetKeysRequest, out *KeyListResponse) error {
	return h.KeyServiceHandler.GetKeys(ctx, in, out)
}

func (h *KeyService) GetUserKey(ctx context.Context, in *GetUserKeyRequest, out *KeyResponse) error {
	return h.KeyServiceHandler.GetUserKey(ctx, in, out)
}

func (h *KeyService) GetUserKeys(ctx context.Context, in *GetUserKeysRequest, out *KeyListResponse) error {
	return h.KeyServiceHandler.GetUserKeys(ctx, in, out)
}

func (h *KeyService) RemoveKey(ctx context.Context, in *RemoveKeyRequest, out *KeyResponse) error {
	return h.KeyServiceHandler.RemoveKey(ctx, in, out)
}

func (h *KeyService) UpdateKeyDescription(ctx context.Context, in *KeyRequest, out *KeyResponse) error {
	return h.KeyServiceHandler.UpdateKeyDescription(ctx, in, out)
}

func init() { proto.RegisterFile("proto/key/key.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 460 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x54, 0x4d, 0x6b, 0xdb, 0x40,
	0x10, 0x8d, 0x6c, 0x47, 0x6e, 0x46, 0x6e, 0xe3, 0x4c, 0x42, 0x58, 0x7c, 0x72, 0x17, 0x02, 0x3e,
	0x94, 0x6d, 0x71, 0xa0, 0xe7, 0x06, 0x0c, 0x21, 0xb8, 0x27, 0x95, 0xfc, 0x80, 0xad, 0x34, 0x4d,
	0x85, 0x88, 0xa5, 0x6a, 0xd7, 0xa1, 0xfb, 0xb7, 0xda, 0x5b, 0x7f, 0x5d, 0xd9, 0x95, 0x6c, 0xad,
	0xac, 0xd2, 0x42, 0x7b, 0xe8, 0xc1, 0xe0, 0x37, 0xfb, 0xf1, 0xde, 0xbc, 0x79, 0x2b, 0x38, 0x2f,
	0xab, 0x42, 0x17, 0xaf, 0x73, 0x32, 0xf6, 0x27, 0x1c, 0xe2, 0x3f, 0x02, 0x80, 0x35, 0x99, 0x98,
	0xbe, 0x6c, 0x49, 0x69, 0xbc, 0x80, 0xe3, 0x9c, 0xcc, 0xdd, 0x8a, 0x05, 0xf3, 0x60, 0x71, 0x12,
	0xd7, 0x00, 0x2f, 0x21, 0xdc, 0x2a, 0xaa, 0xee, 0x56, 0x6c, 0xe0, 0xca, 0x0d, 0xc2, 0x19, 0x3c,
	0xa3, 0xaf, 0xc9, 0x67, 0xb9, 0x79, 0x20, 0x36, 0x74, 0x2b, 0x7b, 0x8c, 0x53, 0x18, 0xe6, 0x64,
	0xd8, 0xc8, 0x95, 0xed, 0x5f, 0x7b, 0x8b, 0xa2, 0xa4, 0x22, 0xcd, 0x8e, 0xeb, 0x5b, 0x6a, 0x84,
	0x73, 0x88, 0x52, 0x52, 0x49, 0x95, 0x95, 0x3a, 0x2b, 0x36, 0x2c, 0x74, 0x8b, 0x7e, 0xc9, 0x9d,
	0xd4, 0x52, 0x6f, 0x15, 0x1b, 0x37, 0x27, 0x1d, 0xe2, 0x37, 0x70, 0x76, 0x4b, 0xfa, 0x5e, 0x51,
	0xe5, 0xb5, 0xd0, 0x8a, 0x0d, 0x3a, 0x62, 0xf7, 0xad, 0x0d, 0xbc, 0xd6, 0xf8, 0x02, 0x5e, 0xdc,
	0x92, 0x5e, 0x93, 0x51, 0xde, 0x79, 0xb7, 0xa4, 0x58, 0x30, 0x1f, 0xda, 0xf3, 0x35, 0xe2, 0xaf,
	0x00, 0x5b, 0x32, 0xf5, 0x07, 0x36, 0xfe, 0x0e, 0xa6, 0x31, 0x3d, 0x16, 0x4f, 0xf4, 0xd7, 0xca,
	0xbe, 0x07, 0x30, 0x5c, 0x93, 0xf9, 0x2f, 0x23, 0x69, 0x0d, 0x0f, 0x7d, 0xc3, 0x0f, 0x47, 0x35,
	0xee, 0x8d, 0x8a, 0x5f, 0x41, 0xd4, 0x58, 0xb4, 0x92, 0x5a, 0xe2, 0x65, 0x4d, 0x69, 0xa5, 0x47,
	0xcb, 0x91, 0xb0, 0x66, 0xd8, 0x02, 0x5f, 0xc0, 0x64, 0xe7, 0xa4, 0xdb, 0xc7, 0x60, 0x94, 0x93,
	0xa9, 0x2d, 0xdf, 0x6d, 0x74, 0x15, 0x2e, 0x21, 0x72, 0x16, 0xaa, 0xb2, 0xd8, 0x28, 0xf2, 0x94,
	0x05, 0x1d, 0x65, 0x0c, 0xc6, 0x8f, 0xa4, 0x94, 0x7c, 0xa0, 0xc6, 0x90, 0x1d, 0xc4, 0x39, 0x8c,
	0x52, 0xa9, 0xa5, 0x73, 0x23, 0x5a, 0x4e, 0x84, 0x27, 0x2f, 0x76, 0x2b, 0xfc, 0x13, 0x9c, 0xae,
	0xc9, 0xbc, 0xcf, 0x94, 0xfe, 0x07, 0x9a, 0x97, 0x1d, 0x9a, 0xe7, 0xc2, 0x6f, 0xaf, 0xe6, 0x59,
	0x7e, 0x1b, 0xb8, 0xb7, 0xf6, 0x81, 0xaa, 0xa7, 0x2c, 0x21, 0xbc, 0x82, 0xf0, 0x26, 0x4d, 0xed,
	0x88, 0x23, 0xd1, 0xa6, 0x64, 0x36, 0x11, 0x5e, 0xbf, 0xfc, 0x08, 0x05, 0x8c, 0x9b, 0x84, 0xe2,
	0xa9, 0xe8, 0x66, 0x75, 0x36, 0x15, 0x07, 0xc2, 0xf9, 0x11, 0xbe, 0x01, 0x68, 0x73, 0x8a, 0x28,
	0x7a, 0x2f, 0xa4, 0xc7, 0xf0, 0x16, 0x22, 0x2f, 0xd9, 0x78, 0x2e, 0xfa, 0x39, 0xff, 0x25, 0x93,
	0x80, 0x93, 0x7d, 0xc6, 0xf1, 0x4c, 0x1c, 0xe6, 0xbd, 0xc7, 0x73, 0x0d, 0x17, 0xf7, 0x65, 0x2a,
	0xb5, 0xdd, 0xb3, 0xf2, 0x9e, 0xf7, 0xef, 0xda, 0xff, 0x18, 0xba, 0xef, 0xd4, 0xf5, 0xcf, 0x00,
	0x00, 0x00, 0xff, 0xff, 0xc7, 0x8f, 0x7e, 0xae, 0xbe, 0x04, 0x00, 0x00,
}
